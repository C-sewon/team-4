#include "raylib.h"
#include <stdlib.h>
#include <time.h>

#define SCREEN_WIDTH 900
#define SCREEN_HEIGHT 500
#define LINE_Y (SCREEN_HEIGHT / 2)
#define SPEED 300
#define HIT_X 180               // 판정 영역의 왼쪽 위치
#define JUDGE_WIDTH 80          // 판정 직사각형 너비
#define TOLERANCE 80            // 판정 범위 (느슨하게)

typedef struct {
    int type;      // 0=←, 1=↓, 2=↑, 3=→
    float x;       // X 좌표
    int active;    // 활성화 여부
} Note;

#define MAX_NOTES 20
Note notes[MAX_NOTES];
float spawnTimer = 0;
float nextSpawnTime = 0; // 다음 노트 생성까지 랜덤 시간
int gameOver = 0;

void SpawnNote() {
    for (int i = 0; i < MAX_NOTES; i++) {
        if (!notes[i].active) {
            notes[i].active = 1;
            notes[i].type = rand() % 4;
            notes[i].x = SCREEN_WIDTH + 100;
            break;
        }
    }
}

void ResetNotes() {
    for (int i = 0; i < MAX_NOTES; i++) notes[i].active = 0;
}

int main(void) {
    InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, "Music Game");
    SetTargetFPS(60);
    srand(time(NULL));
    ResetNotes();
    nextSpawnTime = (float)(rand() % 1000) / 1000.0f + 0.5f; // 0.5 ~ 1.5초 랜덤

    while (!WindowShouldClose()) {
        float dt = GetFrameTime();

        if (!gameOver) {
            // --- 노트 생성 ---
            spawnTimer += dt;
            if (spawnTimer > nextSpawnTime) {
                SpawnNote();
                spawnTimer = 0;
                nextSpawnTime = (float)(rand() % 1000) / 1000.0f + 0.5f; // 0.5~1.5초 랜덤
            }

            // --- 노트 이동 ---
            for (int i = 0; i < MAX_NOTES; i++) {
                if (notes[i].active) {
                    notes[i].x -= SPEED * dt;

                    // 판정선 지나침 → MISS
                    if (notes[i].x < HIT_X - TOLERANCE) {
                        gameOver = 1;
                    }
                }
            }

            // --- 입력 체크 ---
            if (IsKeyPressed(KEY_LEFT) || IsKeyPressed(KEY_DOWN) ||
                IsKeyPressed(KEY_UP) || IsKeyPressed(KEY_RIGHT)) {

                int keyType = -1;
                if (IsKeyPressed(KEY_LEFT)) keyType = 0;
                else if (IsKeyPressed(KEY_DOWN)) keyType = 1;
                else if (IsKeyPressed(KEY_UP)) keyType = 2;
                else if (IsKeyPressed(KEY_RIGHT)) keyType = 3;

                int hit = 0;
                for (int i = 0; i < MAX_NOTES; i++) {
                    if (notes[i].active && notes[i].type == keyType &&
                        (notes[i].x > HIT_X - TOLERANCE && notes[i].x < HIT_X + JUDGE_WIDTH + TOLERANCE)) {
                        notes[i].active = 0;
                        hit = 1;
                        break;
                    }
                }
                if (!hit) gameOver = 1;
            }
        }

        // --- 그리기 ---
        BeginDrawing();
        ClearBackground(RAYWHITE);

        // 중앙 가로선
        DrawLine(0, LINE_Y, SCREEN_WIDTH, LINE_Y, GRAY);

        // 판정 직사각형 영역
        DrawRectangle(HIT_X, LINE_Y - 50, JUDGE_WIDTH, 100, Fade(LIGHTGRAY, 0.4f));
        DrawRectangleLines(HIT_X, LINE_Y - 50, JUDGE_WIDTH, 100, DARKGRAY);
        DrawText("Click!", HIT_X + 10, LINE_Y - 80, 20, DARKGRAY);

        // 노트(화살표) 크게 표시
        for (int i = 0; i < MAX_NOTES; i++) {
            if (notes[i].active) {
                Color c = BLACK;
                const char* arrow = "";

                switch (notes[i].type) {
                case 0: c = RED; arrow = "<"; break;
                case 1: c = BLUE; arrow = "v"; break;
                case 2: c = GREEN; arrow = "^"; break;
                case 3: c = ORANGE; arrow = ">"; break;
                }

                DrawText(arrow, (int)notes[i].x, LINE_Y - 25, 50, c);
            }
        }

        if (gameOver)
            DrawText("GAME OVER!", SCREEN_WIDTH / 2 - 130, SCREEN_HEIGHT / 2 - 70, 50, RED);

        EndDrawing();
    }

    CloseWindow();
    return 0;
}
